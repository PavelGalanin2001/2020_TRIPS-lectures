---

---

не редактировано

## Окончание Ресурсы События

Можно изменить статический ресурс. Нужно менять не сам объект по ключу, а его отдельные свойства.

Пример на экране:

```csharp
private void Button_Click(object sender.RoutedEventArgs e)
{
    SolidColorBrush buttonBrush = (SolidColorBrush) this.TryFindResource("buttonBrush");
    buttonBrush.Color = Colors.LimeGreen;
}
```

При определении статических ресурсов, ресурсы элементов применяются только к вложенным элементам, но не к внемним контейнерам.

## Иерархия ресурсов

При определении статических ресурсов ресурсы элемента применяются только к вложенным элементам, но не к внешни контейнерам (Поэтому большинство ресурсов определяются в коллекции Windows.Resources в качестве ресурсов окна)

В случае динамических ресурсов такого ограничения нет.

## Установка динамического ресурсов в коде C#

```csharp
LinearGradientBrush gradientBrush = new LinearGradientBrush();
gradientBrush.GradientStops.Add(new GradientStop(Colors.LightGray, 0));
gradientBrush.GradientStops.Add(new GradientStop(Colors.White, 1));
this.Resources.Add("buttonGradientBrush", gradientBrush);

button1.SetResourceReference(Button.BackgroundProperty, "buttonGradientBrush");
```

Общая форма установки

```csharp
объект.SetResourceReference(Класс_объекта.Свойсто_КлассаProperty, ключ_ресурса);
```

С помощью свойства Add объект кисти и его произвольный ключ добавляются в словарь. Дальше с помощью метода TryResource мы пытаемся найти ресур в словаре и установить его в качестве фона. TryFindResource возвращает object, поэтому нужно выполнить приведение типа. Для поиска нового ресурса в коллекции ресурсов у каждого элемента определены методы findResource и TryFindResource.

Отличие в том, что findResource генерирует ислючение, если ресурс с нужным ключом не найден. TryFindResource возвращает Null.

У словоря ClassResourceDictonory можно выделить следующие методы и свойства
- метод Add. У него первый аргумент key dnjhjq куыщгксу. добавляет объект key в словарь
- метод Remove(string key) удаляет из словаря ресур с ключом key
- свойство URI устанавливает источник словаря (путь)
- свойство keys - возвращает все имеющие в словаре ключи
- свойство values - возвращает все имеющие в словаре объекты

## Установка Динамических ресурсов в коде C#

```csharp
LinearGradientBrush gradientBrush = new LinearGradientBrush();
gradientBrush.GradientStops.Add(new GradientStop(Colors.LightGray, 0));
gradientBrush.GradientStops.Add(new GradientStop(Colors.White, 1));
this.Resources.Add("buttonGradientBrush", gradientBrush);

button1.TryFindResource("buttonGradientBrush");
```

Здесь вместо TryFindResource применяется setReference


Для установки выполняется метод SetResourceReference который есть у большинства ресурсов .PF

первый параметр - задается свойство объекта
второй параметр - ключ ресурса

Общая форма установки

```csharp
объект.SetResourceReference(Класс_объекта.Свойсто_КлассаProperty, ключ_ресурса);
```

## Элемента StaticResource и DynamicResource

В ряде случаев в XAML более удобно использовать не фигурные скобки, а полноценные элементы DynamicResource и StaticResource в виде:

```xml
<Window>
    <Window.Resources>
        <Solid >
        ...
    </Window.Resources>
    <Grid>
        <Button
            x:Name="button1"
            MaxWidth="80"
            MaxHeight="40"
            Content="OK"
        >
            <Button.Background>
                <DynamicResource ResourceKey="buttonBrush" />
            </Button.Background>
        </Button>
    </Grid>
</Window>
```

Видим из примера ... ResourceKey - свойство, которое позволяет применять значение применяемого ресурса

Такой вид может быть эффективен в случае использования контейнера.

```xml
<Window>
    <Window.Resources>
        <Button
            x:Name="buttonRes"
            x:Shared="False"
            Content="OK"
            MaxHeight="40"
            MaxWidth="80"
            Background="Azure"
        />
    </Window.Resources>
    <StackPanel>
        <StaticResource RecourceKey="buttonRes" />
        <StaticResource RecourceKey="buttonRes" />
        <StaticResource RecourceKey="buttonRes" />
        <StaticResource RecourceKey="buttonRes" />
    </StackPanel>
</Window>
```



## Разделяемые ресурсы

Когда один и тотже ресурс используется в разных местам, то фактически мы используетм один и тот же объект. Это не всега желается, когда в примере нужно 4 не зависимых кнопки. Иногда необходимо чтобы применение ресурсов к разным ресурсам различалось. То есть необходимо, чтобы при каждом применении создавался отдельный объект ресурса. В этом слечае мы используется Shared="False".

---

Конец темы с ресурсами

---











# События

События - это сообщение, которе посылается объектом для уведомления кода о том, что произошло, что-то важное. Для элементом управления dotPF определено большое количество событий, которые можно разделить на несколько групп.
- событие клавиатуры
- событие мыши
- событие стилуса
- событие сенсорного экрана/мультитач
- событие жизненого цикла

Подключение обработчика событий

Мы можем получить декларативно используя атрибут имя события = и метод обработчика событий

Также можем подключить событие в файле отдельного кода

В примере мы добавили ещё один обработчик, чтобы работало сразу два обработчика.

```csharp
public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
        Button1.Click += Button1_Click;
    }
    //обработчик, подключаемый в XAML
    private void Button_Click(object sender, RoutedEventArgs e)
    {
        MessageBox.Show("Hi from Button_Click");
    }
    // обработчик, подключаемый в конструкторе
    private void Button1_Click(object sender, RoutedEventArgs e)
    {
        MessageBox.Show("Hi from Button1_Click");
    }
}
```

# (Заголовок) Определение маршрутизированых событий

Маршрутизация возникает в одном элементе, а генерироваться в другом

шелчек в панеле инструментов генерируется в панеле инструментов, а затем содержаших в этом панеле окне. И только тогда передается на переработку коду.

Маршрутизированые события большие транспортные возможности.
 Могут тунелироваться вниз
 А также распостраняться пузырьками на вверх по дереву элементу.
 И по пути запускать обработчики событий

Для определения маршрутизированных событий в классе создается статическое поля по типу RoutedEvent

public static read...ROuted... Это поле имеет суффикс Event после определения это событие регистрируется в статическом конструкторе.

И также класс в котором создается событие, как правило определяет объект обертку над обытным событием.
В этой обертке с помощью метода AddHender происходит добавление обработчика для данного события. А с помощью метода Remove hendler удаления обработчика

Для примера взят класс ButtonBase для всех кнопках.

Использует абстрактный класс Button и Base в том числе и событие клик

```csharp
public abstract class ButtonBase : ContentControl, ...
{
    //определяет событие
    public static readonly RoutedEvent ClickEvent;

    static ButtonBase()
    {
        //регистрация маршрутизированного события
        ButtonBase.ClickEvent = EventManager.RegisterRoutedEvent(
            "Click",
            RoutingStrategy.Bubble,
            typeof(RoutedEventHandler),
            typeof(ButtonBase)
        )
        //..................
    }
    //обертка над событием
    public event RoutedEventHandler Click
    {
        add
        {
            //добавляет обработчика
            base.AddHandler(ButtonBase.ClickEvent, value);
        }
        remove
        {
            //Удаление обработчика
            base.RemoveHandler(ButtonBase.ClickEvent, value);
        }
    }
    // остальное содержание класса
}
```

Тип делигат

**Делигат** - это объект, который может ссылаться на метод. С помощью делигата можно вызывать метод, на который делиг вызвываться

Класс который владеет эти событием routedButtonBase

Маршрутизированные события бывают трех видом

- прямые
Подобны обычным событиям .NET Они возникают в одном элемента и не передается в другие например MouseEventer
- пузырьковые. Поднимаются по иерархии содержания Например MouseDown. Возникает на элемента, затем передается родителю. Затем родителю родителя
- тунелированные событие Отпускаются по иерархии содержания. Например PreviewKeyDown Позволяет перехватить нажатие клавиши на уровне окна в плоть до элемента держащего фокус вплоть до нажатия клавиш

Пусть имеется метка? rjnjhfz bvttn cnfrc gfytk b ldf bpj,hf;tybz

```xml
<label
    SorderBrush="LightBlue"
    SorderThinkness="3"
    Margin="3"
    HorizontalAligment="Center"    
>
    <StackPanel>
        <TextBlock Margin="3" FontSize="13">
            Всем привет:
        <TextBlock>
        <Image Source="grimace.png" Width="80" Height="80"></Image>
        <TextBlock Margin="3" FontSize="13">
            Маршрутизация событий
        <TextBlock>
    </StackPanel>
```

Если пользователь опустит кнопку мыши, когда оно будет на изображении. Возникнет событие ImageMouseDown
MouseDown является пузырьковым событием
Поэтому полсле image сработает StackPanel MouseDown
Затем передаться родителю сработает Label MouseDown
после Label будет окно, которое расположено вверху иерархии
в окне будет последний шанс обработать пузырьковое событие.

Затем если пользователь нажал он отспустит кнопку мыши и в такой последовательности возникнет событие MouseUp

# Класс RoutedEventArgs

При обработке события параметры отправителя содержат ссылку на последнее звено в цепочке. В нашем примере событие перед обработкой всплывает от изображения до ветки.
Поэтому параметр события будет ссылаться на объект метки

В некоторых случает необходимо знать где произошло событие Эту ифномарцию можно получитьс из класса RoutedEventArgs

Его свойства:
- Source указывает какой объект сгенерировал событие
- OriginalSource чаще всего совпадает с Source, но в некоторых случеях спускается глубще по дереву элементом спускаясь по дереву элементов.

Например если щелкнуть мышью ближе в меню окна
со Soyrce будет window
 а border OriginalSource
 потомучто Windows состоит из более мелких элементов

- RoutedEvent 
предоставляет объект RouterEvent для события сгенерированного вашего обработчиком события

последнее Handled позволяет остановить проце пузырькового или тунелированого события

Если элемент упраеления зановит в True... не будте возникать других элементов.



























































































































