## Окончание Ресурсы События

Чтобы изменить статический ресурс нужно менять не сам объект по ключу, а его отдельные свойства:

```csharp
private void Button_Click(object sender, RoutedEventArgs e)
{
    SolidColorBrush buttonBrush = (SolidColorBrush) this.TryFindResource("buttonBrush");
    buttonBrush.Color = Colors.LimeGreen;
}
```

## Иерархия ресурсов

При определении статических ресурсов ресурсы элемента применяются только к вложенным элементам, но не к внемним контейнерам (Поэтому большинство ресурсов определяются в коллекции `Window.Resources` в качестве ресурсов всего окна)

В случае с динамическими ресурсами такого ограничения нет.

## Установка динамического ресурсов в коде C#

```csharp
LinearGradientBrush gradientBrush = new LinearGradientBrush();
gradientBrush.GradientStops.Add(new GradientStop(Colors.LightGray, 0));
gradientBrush.GradientStops.Add(new GradientStop(Colors.White, 1));
this.Resources.Add("buttonGradientBrush", gradientBrush);

button1.SetResourceReference(
    Button.BackgroundProperty,
    "buttonGradientBrush"
);
```

Общая форма установки:

```csharp
объект.SetResourceReference(
    Класс_объекта.Свойсто_КлассаProperty,
    ключ_ресурса
);
```

> С помощью свойства `Add` объект кисти и его произвольный ключ добавляются в словарь. Дальше с помощью метода `TryResource` мы пытаемся найти ресур в словаре и установить его в качестве фона. `TryFindResource` возвращает `object`, поэтому нужно выполнить приведение типа. Для поиска нового ресурса в коллекции ресурсов у каждого элемента определены методы `findResource` и `TryFindResource`.

> Отличие в том, что `findResource` генерирует ислючение, если ресурс с нужным ключом не найден. `TryFindResource` возвращает Null.

> У словоря `ClassResourceDictonory` можно выделить следующие методы и свойства:
> - метод Add. У него первый аргумент key dnjhjq куыщгксу. добавляет объект key в словарь
> - метод Remove(string key) удаляет из словаря ресур с ключом key
> - свойство URI устанавливает источник словаря (путь)
> - свойство keys - возвращает все имеющие в словаре ключи
> - свойство values - возвращает все имеющие в словаре объекты

## Установка Динамических ресурсов в коде C#

```csharp
LinearGradientBrush gradientBrush = new LinearGradientBrush();
gradientBrush.GradientStops.Add(new GradientStop(Colors.LightGray, 0));
gradientBrush.GradientStops.Add(new GradientStop(Colors.White, 1));
this.Resources.Add("buttonGradientBrush", gradientBrush);

button1.TryFindResource("buttonGradientBrush");
```

> Здесь вместо `TryFindResource` применяется `SetResourceReference`

> Для установки выполняется метод `SetResourceReference`, который есть у большинства ресурсов .PF

> первый параметр - задается свойство объекта
> второй параметр - ключ ресурса

Общая форма установки

```csharp
объект.SetResourceReference(
    Класс_объекта.Свойсто_КлассаProperty,
    ключ_ресурса
);
```

## Элемента StaticResource и DynamicResource

В ряде случаев в `XAML` более удобно использовать не фигурные скобки, а полноценные элементы `DynamicResource` и `StaticResource` в виде:

```xml
<Window>
    <Window.Resources>
        <SolidColorBrush
            Color="LimeGreen"
            x:Key="buttonBrush"
        />
    </Window.Resources>
    <Grid>
        <Button
            x:Name="button1"
            MaxWidth="80"
            MaxHeight="40"
            Content="OK"
        >
            <Button.Background>
                <DynamicResource ResourceKey="buttonBrush" />
            </Button.Background>
        </Button>
    </Grid>
</Window>
```

> Видим из примера ... `ResourceKey` - свойство, которое позволяет применять значение применяемого ресурса

Такой вид может быть эффективен в случае использования контейнера.

```xml
<Window>
    <Window.Resources>
        <Button
            x:Name="buttonRes"
            x:Shared="False"
            Content="OK"
            MaxHeight="40"
            MaxWidth="80"
            Background="Azure"
        />
    </Window.Resources>
    <StackPanel>
        <StaticResource RecourceKey="buttonRes" />
        <StaticResource RecourceKey="buttonRes" />
        <StaticResource RecourceKey="buttonRes" />
        <StaticResource RecourceKey="buttonRes" />
    </StackPanel>
</Window>
```

## Разделяемые ресурсы

> Когда один и тотже ресурс используется в разных местам, то фактически мы используетм один и тот же объект. Это не всега желается, когда в примере нужно 4 не зависимых кнопки. Иногда необходимо чтобы применение ресурсов к разным ресурсам различалось. То есть необходимо, чтобы при каждом применении создавался отдельный объект ресурса. В этом слечае мы используется Shared="False".

> Конец темы с ресурсами

<div style="page-break-after: always;"></div>

# События

События - это сообщение, которе посылается объектом для уведомления кода о том, что произошло, что-то важное.

Для элементом управления в WPF определено большое количество событий, которые можно разделить на несколько групп:
- событие клавиатуры
- событие мыши
- событие стилуса
- событие сенсорного экрана/мультитач
- событие жизненого цикла

## Подключение обработчика событий

Мы можем получить декларативно в файле xaml-кода используя атрибут

```
ИмяСобытия = "ИмяМетодаОбработчикаСобытий"
```

Также можем подключить событие стандартным способом в файле отдельного кода

> В примере мы добавили ещё один обработчик, чтобы работало сразу два обработчика.

```csharp
public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
        Button1.Click += Button1_Click;
    }
    //обработчик, подключаемый в XAML
    private void Button_Click(object sender, RoutedEventArgs e)
    {
        MessageBox.Show("Hi from Button_Click");
    }
    // обработчик, подключаемый в конструкторе
    private void Button1_Click(object sender, RoutedEventArgs e)
    {
        MessageBox.Show("Hi from Button1_Click");
    }
}
```

# (Заголовок) Определение маршрутизированых событий

> Маршрутизация возникает в одном элементе, а генерироваться в другом

> щелчек в панеле инструментов генерируется в панеле инструментов, а затем содержаших в этом панеле окне. И только тогда передается на переработку коду.

> Маршрутизированые события большие транспортные возможности. Могут тунелироваться вниз, а также распостраняться пузырьками на вверх по дереву элементу, и по пути запускать обработчики событий

> Для определения маршрутизированных событий в классе создается статическое поля по типу `RoutedEvent`

> `public static readonly RoutedEvent` это поле имеет суффикс `Event` после определения это событие регистрируется в статическом конструкторе.

> И также класс в котором создается событие, как правило определяет объект обертку над обытным событием.

> В этой обертке с помощью метода `AddHender` происходит добавление обработчика для данного события. А с помощью метода `RemoveHandler` удаления обработчика

> Для примера взят класс `ButtonBase` для всех кнопках.

> Использует абстрактный класс `Button` и `Base` в том числе и событие клик

```csharp
public abstract class ButtonBase : ContentControl, ...
{
    // определяет событие
    public static readonly RoutedEvent ClickEvent;

    static ButtonBase()
    {
        // регистрация маршрутизированного события
        ButtonBase.ClickEvent = EventManager.RegisterRoutedEvent(
            "Click",
            RoutingStrategy.Bubble,
            typeof(RoutedEventHandler),
            typeof(ButtonBase)
        )
        // ................................
    }
    // обертка над событием
    public event RoutedEventHandler Click
    {
        add
        {
            // добавление обработчика
            base.AddHandler(ButtonBase.ClickEvent, value);
        }
        remove
        {
            // удаление обработчика
            base.RemoveHandler(ButtonBase.ClickEvent, value);
        }
    }
    // остальное содержание класса
}
```

## Тип делигат

> **Делигат** - это объект, который может ссылаться на метод. С помощью делигата можно вызывать метод, на который делиг вызвываться

> Класс который владеет эти событием `RoutedButtonBase`

Маршрутизированные события бывают трех видом

- прямые (direct) события
    
    Подобны обычным событиям `.NET`. Они возникают в одном элемента и не передается в другой.
    
    Например, прямым является событие `MouseEnter`, которое возникает, когда указатель мыши наводится на элемент.

- пузырьковые (bubbling) события

    Поднимаются по иерархии содержания.
    
    Например, пузырьковым событием является `MouseDown`. Оно возникает на в элементе, на котором был произведён щелчок, потом передается от этого элемента к родителю, затем родителю от этого родителя, и т. д., пока WPF не достигнет вершины дерева элементов.

- тунелированные (tunneling) события

    Отпускаются по иерархии содержания.
    
    Они позволяют предварительно просматривать (и, возможно, останавливать) событие, прежде чем оно дойдёт до подходящего элемента управления.

    Например, `PreviewKeyDown` позволяет перехватить нажатие клавиши, сначала на уровне окна, а затем на более специфических контейнерах, вплоть до элемента, содержавшего фокус в момент нажатия клавиши.

При регистрации маршрутизируемого события с помощью метода `EventManager.RegisterEvent()` ему передается значение из перечисления `RoutingStrategy`, которое задает необходимое поведение для события.

> Пусть имеется метка, которая имеет `StackPanel` и два изображения

```xml
<Label
    BorderBrush="LightBlue"
    BorderThickness="3"
    Margin="3"
    HorizontalAlignment="Center"    
>
    <StackPanel>
        <TextBlock Margin="3" FontSize="13">
            Всем привет:
        </TextBlock>
        <Image Source="grimace.png" Width="80" Height="80"></Image>
        <TextBlock Margin="3" FontSize="13">
            Маршрутизация событий
        </TextBlock>
    </StackPanel>
</Label>
```

![картинка-результат выполнения кода]()

> Если пользователь опустит кнопку мыши, когда оно будет на изображении. Возникнет событие `ImageMouseDown`. `MouseDown` является пузырьковым событием, поэтому полсле `Image` сработает `StackPanelMouseDown`. Затем передаться родителю - сработает `LabelMouseDown`. После `Label` будет окно, которое расположено вверху иерархии. В окне будет последний шанс обработать пузырьковое событие.

> Затем, если пользователь нажал, то он отспустит кнопку мыши - и в такой последовательности возникнет событие `MouseUp`.

# Класс RoutedEventArgs

> При обработке события параметры отправителя содержат ссылку на последнее звено в цепочке. В нашем примере событие перед обработкой всплывает от изображения до ветки. Поэтому параметр события будет ссылаться на объект метки.

> В некоторых случает необходимо знать где произошло событие. Эту иyфомарцию можно получить из класса `RoutedEventArgs`.

Все маршрутизируемые события используют класс `RoutedEventArgs` (или его наследников), который представляет доступ к следующим свйоствам:

- `Source`
    элемент логического дерева, являющийся источником события

    > указывает какой объект сгенерировал событие

- `OriginalSource`
    элемент визуального дерева, являющийся источником события. Обычно тоже самое, что и Source
    
    > чаще всего совпадает с Source, но в некоторых случеях спускается глубже по дереву элементом спускаясь по дереву элементов.

    > Например, если щелкнуть мышью ближе в меню окна со `Source` будет `Window`, а `Border` `OriginalSource`, потому что `Window` состоит из более мелких элементов

- `RoutedEvent`
    представляем имя событий

    > предоставляет объект `RouterEvent` для события сгенерированного вашего обработчиком события

- `Handled`
    Если это свойство установлено в `True` событие не будет подниматься и опускаться, а ограничится непосредственным источником.

    > позволяет остановить процесс пузырькового или тунелированого события

    > Если элемент упраеления зановит в True... не будте возникать других элементов.
