Grid

Организует пространство как таблицу настраивыыми столбцами и строками. Дочерними элементы размещаются в указанных ячейках таблиц.

```xml
<Grid>
    <Grid.ColumnDefinitions>
        <ColumnDefinitions Width="100"/>
        <ColumnDefinitions Width="Auto"/>
        <ColumnDefinitions Width="*"/>
    </Grid.ColumnDefinitions>
    <Grid.RowDefinitions>
        <RowDefinitions Height="*"/>
        <RowDefinitions Height="2*"/>
    </Grid.RowDefinitions>
    <Button Grid.Column="0" Grid.Row="0"
        Background="Red" Content="One"/>
    <Button Grid.Column="1" Grid.Row="0" Width="60"
        Background="Orange" Content="Two"/>
    <Button Grid.Column="2" Grid.Row="0"
        Background="Yellow" Content="Three"/>
    <Button
    Grid.Column="0" Grid.Row="1"
        Background="Lime" Content="Four"/>
    <Button
        Grid.Column="1" Grid.Row="1" Grid.ColumnSpan="2"
        Background="Aqua" Content="Five"/>
</Grid>
```

При настройке `Grid` нужно задать набор столбцов и строк с помощью колекции `ColumnDefinitions` и RowDefinitions. Для столбцов может указана высота, для строк ширина. При этом допустимо использовать абсолютное значение, подбор по содержимому (Auto), или пропортиональный размер (`*`). В случае со * Может стоять коэффициент пропорциональности (`2*`)

Высота второй строки = высоте второй строки и не зависимости от высоты окна.

Дочерние элементы связываються с ячейками Grid С помощью свойств `Grid.Column` и `Grid.Row`

Присоединеные свойства см в лаб 2.

Если несколько элементов расположены в одной ячейке они наслаиваються друг на друга.

Один элемент может занять несколько ячеек. Определяют значение для определённых свйойств `Grid.ColumnSpan` и `Grid.RowSpan`

## Grid Spliter

Grid Позволяет изменять размеры столбцов и строк при помощи перетаскивания, если используеться элемент GridSplitter

Правило работы с этим элементом. GridSplitterG должен помещен в ячейку `Grid`. Лутчший подход... Со значением `Height` или `Width = Auto`. 

2. GridSplitter всегда изменяет размер строки или столбца, а не отдельной ячейки. И чтобы это было видно визуально, чтобы сделать внешний вид, нужно растянуть по строке или стобцу и использовать Grid.ColumnSpan или Grid.RowSpan.

3. Когда перетаскиваем элемент в окно он будет мал, что его не будет видно, поэтому нужно дать мин размер. В случаем `VerticalAligment="Stretch"` вертикальной полосы верртикал алигмант = стретс а `Width` какуюто ширину

Выравнивание `GridSplitter` определяет будет полоса горизонтальной или вертикальнойю. В случае вертикальной `HorizontalAligmnet="Center"`.

## Группа с общими размерами

Классы `Row.Definition` обладают строгим свойством `SharedSizeGroup` при помощи которого строки или столбцы объединяються в группу разделяющий размер. Это значит, что при изменении размера одного элемента группы другие элементы получают такой же размер.

Разделение размера может выполнено как в рамках одного Grid так и между  нескольких grid.
В последнем нужно установить `Grid.IsSharedSizeScope="True"` для внешнего контейнера компоновки.

Если изменим текст нижней, то измениться текст верхней колонки.

Можно добавить GridSplitter, тогда пользователь может изменять размер колонки - будет изменяться автоматически.

##

При наличие одного более перекрывающего элемента с помощью присоединеного свойства `Canvas.ZIndex` Можно управлять их расположением. Изначальные элементы имеют `ZIndex="0"`.

Элементы с одинакомым ZIndex отображаються в том порядке.. который представлен в разметке XAML.

Элементы объявлены позже отображаються от элементов объявленых ранее. За счёт ZIndex Элемент можно передвинуть на более высокий уровень.

Действительные значения для `ZIndex` Не важды. Кажно отношение значения `ZIndex`  разных элементов между собой. МОжно указывать положительное или отрицательное число.

Чтобы изменить `ZIndex` Програмно нужно вызвать `Canvas.SetZIndex` и передать этому методу элемент и новое значение `ZIndex`.

## Прокрутка

Необходимость прокрутки возникает если визуальное содержимое выходит за родительские элементы.

Панель прокрутки - это жлемент управления `ScrollViewer`

Го свойства
- VerticalScrollBarVisibility
- HorizontalScrollBarVisibility
управляют видимостью полос прокрутки и принимают значения из перечисления 
- ScrollBarVisability: Vible, Auto Hi

auto - появляеться только тогда когда сожержимое не помещаеться в панеле прокрутки

hidden - полоса прокрутки не видна, но прокрутку можно выполнить в ... или используя клавиатуру

disable - полоса прокрутки не видна и выполнить прокрутку нельзя.

Элемент ScrollViewer Имеет методы
- LineUp()
- LineDown()
- PageUp()
- PageDown()
- ScrollToHome()
- ScrollToEnd()

Горизонтальная прокрутка
- LineLef()
- LineRight()
- PageLeft()
- PageRight()
- ScrollTOHorizontalOffset()
-ScrollToLeftEnd()
- Ы
...

Одной из особеностью ScrollViewer являеться возможность участие в процессе прокурутки.

Такое содержимое должно быть представлено интерфейсом IScrollInfo,
кроме токо нужно установить свойство ScrollViewer.CanContentScroll В значение true



интерфейст IScrollInfo реализует всего несколько элементов один из которых StackPanel

Его реализация интерфейса IScrollInfo Обеспечивает прокрутку, который осузествляет переход от элементка к элементу

```xml
<ScrollViewer CanContentScroll="True">
    <StackPanel>
        <Button Height="100" Content="1" />
        <Button Height="100" Content="2" />
        <Button Height="100" Content="3" />
        <Button Height="100" Content="4" />
    </StackPanel>
</ScrollViewer>
```

## Декораторы

Нужны для токо чтобы графически разнообразить область вокруг объекта. Являеться наследником классы `System Windows Controls Decorator`.

Большинство декораторов - это специальные класса предназначеные для использования вместе с определёными элементами управления.

Есть два общих декоратора, которые не привязаны к элементу управления :Border и ViewBox.

Border - принимает вложеное содержимое и применяет к нему фон и рамку.

 Для управления Border можно использовать свойство размера отступа Margin и padding и некоторые особые свойства backgroud Задает фон декоратора с помощью объекта Brush

 Border brush и border siknes задают цвет и ширину рамки причем чтобы задать ширину из каждых сторон и свойства View Radius закругляет углы (Можно отдельно закруглить каждый угол).

 ```xml
<Border Margin="20" Padding="10" VerticalAligment="Top"
    Background="LightYellow" BorderBrush="SteelBlue"
    BorderThickness="10, 5, 10 5" CornerRadius="5"
>
    <StackPanel>
        <Button Margin="5" Content="One" />
        <Button Margin="5" Content="Two" />
        <Button Margin="5" Content="Three" />
    </StackPanel>
</Border>
 ```

Декоратор ViewBox

Маштабирует свое так чтобы поместилось в декораторе. Сохраняет пропорции содержимого, хотя их можно изменить

Если свойству Stretch присвоить значение Fill, то содержиммое будет растянуто

слайд

# Свойства зависимостей

Знаем что у любого баз элемента есть видтх хеикг и др

в дот пф они не являються свойствами языка си шарп

Свойства зависимости - новая модель свойст используеться для реализации следующих механизмов

- Уведомления об изменении значении свойства
- сброс свойства к значению по умолчанию
- наследования значения свойства дочерними элементами
- эффективная модель ранения данных свойства
- привязка свойства к данным произвольного объекта

ПРи вычисления значения любого свойства зависимости .PF использует алгоритм состоящий из 5-ти шагов

1. Определение базового значения
 этот шаг подрузумевает использование слудующих источников, которые указаны в порядке приоритета
 локально указаного значения в разметуке или коде
 значение полученное от тригера стиля
 значение полученное от тригера шаблона
 значение задданное в стиле
 значение полученное от тригера общего стиля
 значение заданное в общем стиле
 значение унаследованное от родительского элемента
 значение по умолчанию

 Тригер стиля шаблоны будем изучать и делать в лабах

2. Вычисления значений
Если базовае значение выражаеться привязкой данных или ресурсов производиться вычисление варажения

3. Приминение анимаций
Если со свойством связана анимация, значение вычисляеться по алгориму этой анимации.

4. Вычисление функции `Coerce value callback` такая функция может быть определена при регисрации свойства заисимостей.
Её назначение, коректировка значения свойства на основании пользовательского алгоритма.

5. Проверка значения

validate value callback Которая вызывается для проверки значения
В случае провала генерируеться исключение

Рассмотрим схему в пользоватльском типе.

Схема включает три этапа

1. СОздание объекта характеризующие метаданные свойства зависимости. (МОжет свойство наследоваться или нет, какое значение по умолчанию) (Необязательный)
Этот этап являеться не обязательным потомучто мета данные могут быть установлены по умолчанию
2. Собственная регистрация своства зависисомтис (обязательный)
3. СОздания экземплярной оболчик для свойства зависимости (необязательный)

